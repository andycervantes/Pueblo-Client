/*----------------------------------------------------------------------------
                        _                              _ _       
        /\             | |                            | (_)      
       /  \   _ __   __| |_ __ ___  _ __ ___   ___  __| |_  __ _ 
      / /\ \ | '_ \ / _` | '__/ _ \| '_ ` _ \ / _ \/ _` | |/ _` |
     / ____ \| | | | (_| | | | (_) | | | | | |  __/ (_| | | (_| |
    /_/    \_\_| |_|\__,_|_|  \___/|_| |_| |_|\___|\__,_|_|\__,_|

    The contents of this file are subject to the Andromedia Public
	License Version 1.0 (the "License"); you may not use this file
	except in compliance with the License. You may obtain a copy of
	the License at http://www.andromedia.com/APL/

    Software distributed under the License is distributed on an
	"AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
	implied. See the License for the specific language governing
	rights and limitations under the License.

    The Original Code is Pueblo client code, released November 4, 1998.

    The Initial Developer of the Original Code is Andromedia Incorporated.
	Portions created by Andromedia are Copyright (C) 1998 Andromedia
	Incorporated.  All Rights Reserved.

	Andromedia Incorporated                         415.365.6700
	818 Mission Street - 2nd Floor                  415.365.6701 fax
	San Francisco, CA 94103

    Contributor(s):
	--------------------------------------------------------------------------
	   Chaco team:  Dan Greening, Glenn Crocker, Jim Doubek,
	                Coyote Lussier, Pritham Shetty.

					Wrote and designed original codebase.

------------------------------------------------------------------------------

	Declaration for the ChMazeWnd class, which is used to display
	3d graphics.

----------------------------------------------------------------------------*/

// $Header: /home/cvs/chaco/modules/client/msw/ChGraphx/ChMaze.h,v 2.99 1996/07/21 00:04:10 pritham Exp $

#if !defined( _CHMAZE_H )
#define _CHMAZE_H

#if defined( CH_MSW )
	#pragma warning( disable:4091 )
#endif	// defined( CH_MSW )

#include <math.h>

#if !defined(CH_VRML_PLUGIN )
#include <ChHook.h>
#endif

#include <ChKeyMap.h>

#include "ChGrType.h"
#include <ChGraphx.h>
#include "ChGrVw.h"
#include <ChDibImage.h>

#include <ChHTTP.h>


// The Renderer to use is selected at compile-time only
#include "ChGrRend.h"

#include <QvDB.h>
#include <QvInput.h>
#include <QvNode.h>
#include <QvState.h>
#include <QvNodes.h>
#include <QvInput.h>

#include "ChRender.h"

class ChGrTextureHandler;

class QvNode;
class QvShapeHints;
class ChMazeMainInfo;
class ChRenderContext;
class ChQvState;
class ChMazeCameraControl;
class ChQvAnchorSensor;
class ChQvBounds;
class ChParseInfo;
class ChGraphicStreamManager;


class ChVrmlStateTransition;

typedef ChQvAnchorSensor *pChQvAnchorSensor;
typedef ChParseInfo *pChParseInfo;

// Change this to use the non-stub version
#if defined(CH_VRML_EVENTS)	 && !defined( CH_VRML_PLUGIN )
class ChStubBrowser;
#define ChVrmlBrowser	ChStubBrowser
#endif

/*----------------------------------------------------------------------------
	Constants
----------------------------------------------------------------------------*/

/* Progress message IDs */

#define PROGRESS_MSG_0   	0		// ""
#define PROGRESS_MSG_1   	1		// "Geometry computation complete"
#define PROGRESS_MSG_2   	2		// "Computing scene geometry"
#define PROGRESS_MSG_3		3		// "Decoding texture"


#define ACCEL_FACTOR		1.6


// Error code generated by maze

#define 	CH_MAZE_PARSE_ERROR_BASE			0x10000000
#define 	CH_MAZE_PARSE_ERROR_SYNTAX			( CH_MAZE_PARSE_ERROR_BASE + 1 )

#define 	CH_MAZE_ROUTE_ERROR_BASE			0x20000000
#define 	CH_MAZE_ROUTE_ERROR_NODE_NOTFOUND		( CH_MAZE_ROUTE_ERROR_BASE + 1 )
#define 	CH_MAZE_ROUTE_ERROR_INVALID_ADD			( CH_MAZE_ROUTE_ERROR_BASE + 2 )
#define 	CH_MAZE_ROUTE_ERROR_INVALID_REMOVE		( CH_MAZE_ROUTE_ERROR_BASE + 3 )
#define 	CH_MAZE_ROUTE_ERROR_FIELD_MISMATCH		( CH_MAZE_ROUTE_ERROR_BASE + 4 )
#define 	CH_MAZE_ROUTE_ERROR_EVENT_NOTFOUND		( CH_MAZE_ROUTE_ERROR_BASE + 5 )

#define 	CH_MAZE_HTTP_ERROR_BASE				0x30000000
// All http error are 	CH_VRML_HTTP_ERROR_BASE + http error code


/*----------------------------------------------------------------------------
	Typedefs and helper classes
----------------------------------------------------------------------------*/
class ChRegistry;

class ChVrmlSettings
{
	public:
	
	enum whichPreference {	
		moveVector = 0x01, 
		scaleTextures = 0x02,
		renderQuality= 0x04,            
		moveRenderQuality = 0x08,        
		headlightBrightness = 0x10,
		viewerMode = 0x20,
		asciiTextQuality = 0x80,
		headlightOn = 0x100,                
		collisionMode = 0x200,
		collisionAlarm = 0x400,
		headlightSwitch = 0x1000,
		renderOptimization = 0x2000
	};
	
	
	 
	public:

		ChVrmlSettings() :
			m_boolMoveVector(GR_PREFS_DRAW_MOVE_VECTOR_DEF),              
			m_boolScaleTextures(GR_PREFS_DRAW_SCALE_PAT_DEF),           
			m_renderQuality(smoothShading),
			m_moveRenderQuality(smoothShading),
			m_fHeadlightBrightness(GR_PREFS_HEADLIGHT_BRIGHTNESS_DEF),        
		 	m_viewerMode(Ch3DViewerMode(GR_PREFS_VIEWER_MODE_DEF)),
			m_iAsciiTextQuality(GR_PREFS_ASCII_TEXT_QUALITY_DEF),
			m_boolHeadlightOn( false ),
			m_collisionMode(GR_PREFS_COLLISION_MODE_DEF),              
			m_boolCollisionAlarm(GR_PREFS_COLLISION_ALARM_DEF),         
			m_optimization(GR_PREFS_RENDER_OPTIMIZATION_DEF)  
			{};
		
	 
		inline float GetHeadlightBrightness() { return m_fHeadlightBrightness;};
		inline ChShadingLevel GetRenderQuality() { return m_renderQuality; }
		inline ChShadingLevel GetMoveRenderQuality()
						{
							return m_moveRenderQuality;
						}
		inline bool GetMoveVector() { return m_boolMoveVector; }
		inline bool GetScaleTextures() { return m_boolScaleTextures; }
 		inline Ch3DViewerMode GetViewerMode()
						{
							return (Ch3DViewerMode)m_viewerMode;
						}
 		inline int GetAsciiTextQuality()
						{
							return m_iAsciiTextQuality;
						}
 		inline bool GetHeadlightSwitch()
 			{ 
 				return m_boolHeadlightOn; 
 			};

 		 inline Ch3DCollisionMode GetCollisionMode( ) { return m_collisionMode;};
 		 inline bool GetCollisionAlarm() { return m_boolCollisionAlarm;};

		inline ChRenderOptimization GetRenderOptimization() { return m_optimization; }

		void ReadPreferences(const string& strCompanyName, const string& strProduct,
						const string& strGroup);
		//void ReadPreferences(ChRegistry *pReg);
		bool UpdatePreferences( bool boolMoveVector,
										bool boolScaleTextures,
										ChShadingLevel renderQuality,
										ChShadingLevel moveRenderQuality,
										float fHeadlight,
										int iAsciiTextQuality );

		bool UpdatePreferences( bool boolMoveVector,
										bool boolScaleTextures,
										ChShadingLevel renderQuality,
										ChShadingLevel moveRenderQuality,
										float fHeadlight,
										int iAsciiTextQuality,
										bool boolCollisionAlarm  );

		 ChVrmlSettings* SetHeadlightBrightness(ChRegistry &reg, float fHeadlightBrightness);
		 ChVrmlSettings* SetRenderQuality(ChRegistry &reg, ChShadingLevel renderQuality);
		 ChVrmlSettings* SetMoveRenderQuality(ChRegistry &reg, ChShadingLevel moveRenderQuality);
		 ChVrmlSettings* SetMoveVector(ChRegistry &reg, bool boolMoveVector);
		 ChVrmlSettings* SetScaleTextures(ChRegistry &reg, bool boolScaleTextures);
 		 ChVrmlSettings* SetViewerMode(ChRegistry &reg, Ch3DViewerMode viewerMode);
 		 ChVrmlSettings* SetAsciiTextQuality(ChRegistry &reg, int iAsciiTextQuality);
		 ChVrmlSettings* SetHeadlightSwitch(ChRegistry &reg, bool headlightOn);

 		 ChVrmlSettings* SetCollisionMode(ChRegistry &reg, Ch3DCollisionMode collisionMode);
 		 ChVrmlSettings* SetCollisionAlarm(ChRegistry &reg, bool boolCollisionAlarm);

		 ChVrmlSettings* SetHeadlightBrightness( float fHeadlightBrightness);
		 ChVrmlSettings* SetRenderQuality( ChShadingLevel renderQuality);
		 ChVrmlSettings* SetMoveRenderQuality( ChShadingLevel moveRenderQuality);
		 ChVrmlSettings* SetMoveVector( bool boolMoveVector);
		 ChVrmlSettings* SetScaleTextures( bool boolScaleTextures);
 		 ChVrmlSettings* SetViewerMode( Ch3DViewerMode viewerMode);
 		 ChVrmlSettings* SetAsciiTextQuality( int iAsciiTextQuality);
		 ChVrmlSettings* SetHeadlightSwitch( bool headlightOn);

 		 ChVrmlSettings* SetCollisionMode(Ch3DCollisionMode collisionMode);
 		 ChVrmlSettings* SetCollisionAlarm(bool boolCollisionAlarm);

		ChVrmlSettings*  SetRenderOptimization(ChRegistry &reg, ChRenderOptimization	optimization);
		ChVrmlSettings*  SetRenderOptimization(ChRenderOptimization	optimization) ;

	protected:
		bool					m_boolMoveVector;
		bool					m_boolScaleTextures;
		ChShadingLevel			m_renderQuality;
		ChShadingLevel			m_moveRenderQuality;

 		float					m_fHeadlightBrightness;
		Ch3DViewerMode			m_viewerMode;
		BOOL					m_boolHeadlightOn;

		Ch3DCollisionMode		m_collisionMode;
		BOOL					m_boolCollisionAlarm;

		int						m_iAsciiTextQuality;

		string					m_strCompanyName;
		string					m_strProduct;
		string					m_strGroup;
		ChRenderOptimization	m_optimization;
		// override this method to get notification when preferences change
		virtual void Notify(chuint32 which);	  // which is what changed
		ChVrmlSettings* SetRegistry(const string& strCompanyName, const string& strProduct,
						const string& strGroup);

};

/*----------------------------------------------------------------------------
	ChMazeWnd class
----------------------------------------------------------------------------*/

class ChMazeWnd : public ChGraphicView
{
	public:
		enum constants { minMoveAmount = 1, maxMoveAmount = 20,
							moveTimerID = 8650657, moveTimerDuration = 33 };

		enum ChCameraChange { cameraMoved = 0x01, cameraTurned = 0x02, cameraSelected = 0x04 };

		enum traceType { traceError = 0x08, traceWarning = 0x10 };

		#if defined(CH_VRML_VIEWER)	 || defined(CH_VRML_PLUGIN )
		ChMazeWnd( );
		#else
		ChMazeWnd( ChMazeMainInfo *pInfo, ChVrmlSettings *pSettings );
		#endif

		#if defined(CH_VRML_VIEWER)	 
		DECLARE_DYNCREATE( ChMazeWnd )
		#endif
		
		static int GetNumMazeObjects()		{ return m_iObjectCount; }

		#if defined(CH_VRML_VIEWER)	|| defined(CH_VRML_PLUGIN )
		virtual void InitMazeView( ChHTTPConn *httpConn, ChVrmlSettings *pSettings  );
		#endif

										// Create a wnd

		bool Create( const CRect& rtView, CWnd* pParent,
						DWORD dwStyle = WS_VISIBLE | WS_BORDER, // | WS_VSCROLL,
						UINT uiID = 0 );

											/* ClassWizard generated virtual
												function overrides */
		//{{AFX_VIRTUAL(ChMazeWnd)
	protected:
		virtual void OnInitialUpdate();     // first time after construct
		virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL


	protected:
		virtual ~ChMazeWnd();

		#if defined( _DEBUG )

			virtual void AssertValid() const;
			virtual void Dump( CDumpContext& dc ) const;

		#endif	// defined( _DEBUG )

 	public:
		virtual void OnError( chuint32 luErrorCode, const string& strMsg, int iType  );
		void OnVRMLActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
		inline ChMazeCameraControl* GetCameraControl()
					{
						return m_pCameraControl;
					}
		#if !defined(CH_VRML_VIEWER) && !defined(CH_VRML_PLUGIN )
		inline ChHookManager* GetCmdHookMgr() { return m_pHookMgr; }
		#endif

		inline ChGraphicPageID GetCurrentPage() { return m_currentPage; }
		#if defined(CH_USE_3DR)
		inline G3dHandle_t GetGC() { return m_RC.GetGC(); }
		#endif
		inline ChNativeContext GetRC() { return m_RC.GetRC(); }
		inline ChRenderContext* GetRenderContext() { return &m_RC; }
		inline QvNode* GetScene() { return m_pRoot; }

		#if !defined(CH_VRML_VIEWER) && !defined(CH_VRML_PLUGIN )
		inline ChMazeMainInfo* GetMainInfo() { return (ChMazeMainInfo*)ChGraphicView::GetMainInfo(); }
//		ChHTTPConn* GetHTTPConn();
		#else
		inline ChHTTPConn* GetHTTPConn() { return m_pHttpConn; }
		#endif

		float GetUserSpeedFactor();
		void  SetUserSpeedFactor(float fSpeed);
		void  ResetUserSpeedFactor();

		float GetMoveAmountAngle();
		float GetMoveAmountDistance();
		ChMazeWnd * GoFaster(bool boolFaster = true );
		inline ChQvBounds *GetBounds() { return m_pBounds; };
		inline bool IsInMouseAnchor() { return m_boolInMouseAnchor; }
		inline bool IsInMouseMove() { return m_boolInMouseMove; }

		#if !defined(CH_VRML_VIEWER) && !defined(CH_VRML_PLUGIN )
		inline void SetCmdHookMgr( ChHookManager *pHookMgr )
					{
						m_pHookMgr = pHookMgr;
					}
		#endif


		ChMazeWnd* SetScene( QvNode *root );

		inline unsigned long GetBackgroundColorL()
			{

				unsigned long val;
				#if defined(CH_USE_3DR)
				unsigned long r, g, b;
				
				r = long( m_backGroundColor.r() * 255.0 );
				g = long( m_backGroundColor.g() * 255.0 );
				b = long( m_backGroundColor.b() * 255.0 );
				val = r | (g << 8) | (b << 16) | 0xff000000;
				#elif defined( CH_USE_RLAB )  || defined(CH_USE_D3D) 
				val = long(*(m_backGroundColor.GetNative()));
				#else
				#endif


				return val;
			}

		virtual void Render( CRect* pClipRect = 0 );
		//bool LoadBackground( const string & strURL );
		bool LoadScene( const string & strURL, const string &strFilename, chparam data );
		bool LoadWWWInline( const string & strURL, const string &strFilename, 
												QvWWWInline *pInlineNode );
		void Spawn( const string &strFilename );

		virtual bool ContinueDraw() {return true;};	 // override to get notification before draw
	    virtual void Draw( CDC* pDC = 0, RECT* pClipRect = 0 );  // Draw to screen

		virtual bool NotifyPaletteChange( UINT uMsg, CWnd* pFocusWnd );

		void AdjustLight( string strCmd, int iLight, float fLevel );
		void DoNodeCommand( string& strCmd, string &strNodeVRML );
		void SetupContexts();
		void SetGlobalHints();
		void SetupTreeDefaults();

		static string EncapsulateVRML( string strNodeVRML );

		void DoAnchor( chint32 lX, chint32 lY );

		void AddAnchor(ChQvAnchorSensor *pAnchor);

		ChMazeWnd* SetHeadlight( bool boolOn );
		inline bool IsHeadlightOn()	{ return GetSettings()->GetHeadlightSwitch();;};
		inline float GetHeadlightBrightness()	{ return GetSettings()->GetHeadlightBrightness();};
		inline Ch3DViewerMode GetSceneViewerMode() {return GetSettings()->GetViewerMode();};
		inline ChVrmlSettings *GetSettings( ) {return m_pSettings; };
 		inline bool IsMoving() { return m_boolMoving; }
		inline void SetMoving( bool boolMoving ) { m_boolMoving = boolMoving; }
  		inline ChGraphicPageID GetNewPage() { return ++m_pageCount; }
		bool GetURL( const string& strURL, chparam userData,
						const char* pstrDefURL = 0);
		string&		GetCurrentURL()			 { return m_strURL; }
		ChMazeWnd *ResetCamera();
 		Ch3DCollisionMode GetCollisionMode( );


		virtual  void OnHotSpot( chparam userData,
								const string& strDocURL  );
		virtual  void  OnUpdateProgress( UINT uMsgID ) {}


		static void TermMazeWnd();
  		void WriteStatus( UINT uMsgID );
		bool CheckForTrailingJunk(QvInput &in );
		int	 GetShapeCount()				{ return m_RC.GetShapeCount(); }

		HANDLE GetEndParseEvent()			{ return m_hParseThreadEvent; }
		// Virtual override function to be called for UI update for new file
		virtual bool OnLoadComplete() {return true;};
	
		#if defined(CH_VRML_EVENTS)	 && !defined( CH_VRML_PLUGIN )
		ChVrmlBrowser * GetBrowser();
		#endif

 		inline ChVrmlStateTransition* GetSceneNavigator()
 		{
 			return ((GetSceneViewerMode() >= 0) ? m_pNavigators[GetSceneViewerMode()] : 0);
		};

		float CalcAccel( float fVal );
		virtual bool OnLeftClick(int x, int y, chuint32 uFlags);
		virtual bool OnRightClick(int x, int y, chuint32 uFlags);

		virtual bool OnCameraChange(ChCameraChange efChanged) {return false;};	 // override to get camera motion updates
		bool GetVelocity(GxVec3f &velocity);	// in world units/sec (usually m/s)
		bool GetAngularVelocity(GxVec3f &axis, float &slewRate); // in rads/sec

		void DisplayMenu( int x, int y, chuint32 uFlags );
		void EndFrameTime();
		void StartFrameTime();


	protected:
		bool NewBackground( ChDib* pDIB );
		void ClearAnchors();

		bool IsAnchor( int iX, int iY ) { ChQvAnchorSensor *pAnchor; return IsAnchor( iX, iY, pAnchor );};
		bool IsAnchor( int iX, int iY, pChQvAnchorSensor &pAnchor );
		void StartAnchor( int iX, int iY );
		void UpdateAnchor( int iX, int iY );
		void EndAnchor( int iX, int iY );

		void StartMouseMove( int iX, int iY );
		void UpdateMouseMove( int iX, int iY );
		void EndMouseMove( int iX, int iY );
		void DrawMouseMoveCrosshair( CDC* pDC );
		void DrawMouseMoveVector( CDC* pDC );
		float CalcMouseHorzMove();
		float CalcMouseVertMove();

		// Parser related methods
		bool AddParseInfo( ChParseInfo* pParseInfo );
		bool RemoveParseInfo( ChParseInfo* pParseInfo );
		bool AbortParsing();

 		virtual void 	OnSettingsChanged();

		HMENU	m_hCameraMenu;
		void FindCameraMenu();
		static HMENU FindMenu(CMenu * pMenu, string &strName);
 		static HMENU FindParentMenu(CMenu * pTopMenu, const HMENU hChildMenu, int &index);
		bool SetupCameraMenu();


	protected:
											// Generated message map functions
		//{{AFX_MSG(ChMazeWnd)
		afx_msg void OnSize(UINT nType, int cx, int cy);
		afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
		afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
		afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
		afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
		afx_msg void OnMouseMove(UINT nFlags, CPoint point);
		afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
		afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
		afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
		afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
		afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
		afx_msg void OnDestroy();
		afx_msg void OnTimer(UINT nIDEvent);
		afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
		afx_msg void OnPaint();
	afx_msg void OnCameraNext();
	afx_msg void OnCameraPrev();
	afx_msg void OnOptResetSpeed();
	afx_msg void OnOptimizeBetter();
	afx_msg void OnOptimizeFaster();
	afx_msg void OnCollisionChecking();
	//}}AFX_MSG

	public:
		afx_msg void OnHeadlightSwitch();
		afx_msg void OnResetCamera();
		afx_msg void OnBrighten();
		afx_msg void OnDimmer();
		afx_msg void OnExamine();
		afx_msg void OnFly();
		afx_msg void OnWalk();

	protected:
		afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	    afx_msg BOOL OnQueryNewPalette();

		afx_msg void OnSysKeyDown( UINT, UINT, UINT );
		afx_msg void OnSysKeyUp( UINT, UINT, UINT );

		afx_msg LONG OnPrefChange( UINT wParam, LONG lParam );
		afx_msg LONG OnProgressMsg( UINT wParam, LONG lParam );
		afx_msg LONG OnMazeError( UINT wParam, LONG lParam );
		afx_msg LONG OnParseError( UINT wParam, LONG lParam );
		afx_msg LONG OnParseComplete( UINT wParam, LONG lParam );
		afx_msg LONG OnLoadTexture( UINT wParam, LONG lParam );
		afx_msg LONG OnVrmlEvent( UINT wParam, LONG lParam );
		afx_msg LONG OnActivateWnd( UINT wParam, LONG lParam );

		afx_msg void OnCameraMenuCommand(UINT uID);
		afx_msg void OnCameraMenuUpdateCommand(CCmdUI* pCmdUI);
		
		DECLARE_MESSAGE_MAP()

	protected:
	    QvNode*					m_pRoot;

		#if defined( CH_USE_OPENGL )

		CDC*					m_pDC;		// DC for OSB dib; OGL will draw here
		HGLRC					m_hRC;		// OGL rendering context

		#elif defined( CH_USE_3DR )

		ChRenderContext			m_RC;

		#elif defined( CH_USE_RLAB ) || defined(CH_USE_D3D)

		ChRenderContext			m_RC;

		#endif

		float					m_fAspect;
		ChColor					m_backGroundColor;
		DWORD					m_luTime;
		#if defined(CH_VRML_VIEWER)	 || defined(CH_VRML_PLUGIN )
		ChHTTPConn				*m_pHttpConn;
		ChGraphicStreamManager	*m_pGraphicStream;
		#endif
		ChGraphicPageID			m_currentPage;
		bool 					m_boolLightOn;

	protected:
		#if !defined(CH_VRML_PLUGIN ) && !defined(CH_VRML_VIEWER)
		ChHookManager*			m_pHookMgr;
		#endif

		ChQvBounds				*m_pBounds;
	    ChDib					m_dibBkgnd;
		ChMazeCameraControl*	m_pCameraControl;
		float 					m_fUserSpeedFactor;
		ChKeyMap				m_keyMap;
		ChPtrList<ChQvAnchorSensor>	m_anchors;
		ChQvAnchorSensor		*m_pAnchor;
		bool 					m_boolIsHintDisplayed;
		HCURSOR					m_hAnchorCursor;
		HCURSOR					m_hCursor;	// current cursor
 		ChGraphicPageID	m_pageCount;	 // page id factory for this viewer; each view object has their current one

		bool					m_boolInMouseAnchor;
		bool					m_boolInMouseMove;

		chint16					m_sCrosshairHalfWidth;
		chint16					m_sCrosshairHalfHeight;
		ChPoint					m_ptMouseStart;
		ChPoint					m_ptMouse;
		ChPoint					m_ptLastMouse;
		UINT					m_uiMoveTimer;
		UINT					m_uiTickTimer;

				  						// Dirty flag after motion for hittesting later
		bool		m_boolMouseMove;
		//Ch3DViewerMode			m_sceneViewerMode;
		bool					m_boolMoving;
		ChVrmlSettings			*m_pSettings;
		//Ch3DCollisionMode 		m_sceneCollisionMode;

		string					m_strURL;
		ChPtrList<ChParseInfo>	m_parseThreadList;
		CRITICAL_SECTION		m_syncParser;
		HANDLE					m_hParseThreadEvent;

		#if defined(CH_VRML_EVENTS)	 && !defined( CH_VRML_PLUGIN )
		ChVrmlBrowser 			*m_pVrmlBrowser;
		#endif

		ChVrmlStateTransition 	*m_pNavigators[viewerModeCount];
		CMenu*					m_pScoutMenu;

		static int				m_iObjectCount;

};


class ChQvState:public QvState
{
	public:
	// Traversal types
	enum type
	{
		draw,
		command,
		editNode,
		findGlobals,
		spawnRequests,
		purgeTree,
		getBounds,
		queryNode,
		buildInstance,
		hitTest
	};

	protected:

	ChMazeWnd*	m_pView;
	int			m_numLights;
	type	m_type;
	string	m_strCmd;
	string	m_strSubCmd;
	string	m_strKey;
	string	m_strVRML;
	int		m_iData;
	float	m_fData;
	// Default proerties
	QvShapeHints		* m_pHint;
	QvMaterialBinding	* m_pMaterialBinding;
	QvMaterial			* m_pMaterial;
	QvPerspectiveCamera	* m_pCamera;


	bool	m_boolKeyFound;	// key is in scope
	bool	m_boolCmdDone;	// for one shot cmds
	QvNode	*m_pNode;		// node from vrml to use in cmd

	public:
	ChQvState(ChMazeWnd* pView);

	// command
	ChQvState(ChMazeWnd* pView, string strCmd, int iData, float fData) :
		QvState(), m_pView(pView), m_numLights(0), m_type(command),
		m_strCmd(strCmd), m_iData(iData), m_fData(fData), m_boolKeyFound(0), m_boolCmdDone(0),
		m_pHint(0), m_pMaterialBinding(0), m_pMaterial(0), m_pCamera(0)
	{};

	// edit node
	ChQvState(ChMazeWnd* pView, string& strCmd, string& strSubCmd,
			string& strKey, string& strVRML, QvNode *pNode) :
		QvState(), m_pView(pView), m_numLights(0), m_type(editNode),
		m_strCmd(strCmd), m_iData(0), m_fData(0), m_boolKeyFound(0), m_boolCmdDone(0),
		m_strSubCmd(strSubCmd),	 m_strKey(strKey),  m_strVRML(strVRML), m_pNode(pNode),
		m_pHint(0), m_pMaterialBinding(0), m_pMaterial(0), m_pCamera(0)
	{};

	// generic to derive
	ChQvState(ChMazeWnd* pView, type aType) :
		QvState(), m_pView(pView), m_numLights(0), m_type(aType),
		m_iData(0), m_fData(0), m_boolKeyFound(0), m_boolCmdDone(0), m_pNode(0),
		m_pHint(0), m_pMaterialBinding(0), m_pMaterial(0), m_pCamera(0)
	{};


	virtual ~ChQvState()
	{
		pop();
		delete m_pHint;
		delete m_pMaterialBinding;
		delete m_pMaterial;
		delete m_pCamera;
	}

	ChQvState& operator=( const ChQvState& v );

	inline ChMazeWnd* GetView() {return m_pView;};
	inline type GetType() {return m_type;};
	inline string& GetCmd() {return m_strCmd;};
	inline string& GetSubCmd() {return m_strSubCmd;};
	inline int GetIData() {return m_iData;};
	inline float GetFData() {return m_fData;};
	inline QvNode	*GetNode() {return m_pNode;};
	inline bool IsKeyFound() {return m_boolKeyFound;};
	inline bool IsCmdDone() {return m_boolCmdDone;};
	inline ChQvState* SetKeyFound(bool val) {m_boolKeyFound = val;return this;};
	inline ChQvState* SetCmdDone(bool val) {m_boolCmdDone = val;return this;};
	inline int NextLight() { return ++m_numLights; };

	virtual void	popElement(StackIndex stackIndex); 		// jwd: needs to be virtual for derivation
	int PopLight() { return m_numLights--; };

	inline QvNode * GetTopNode(StackIndex index)
	{
		QvNode * pNode = 0;

		QvElement *pElt = getTopElement(index);
		if(pElt)
		{
			pNode = (QvNode *)(pElt->data);
		}
		return pNode;
	};

	protected:
		void Kill();
		void Copy(const ChQvState& state);


};


class ChQvGlobalSearchState : public ChQvState
{

	protected:
		float				m_fAspect;
		ChColor				m_backGround;
		ChShadingLevel		m_shading;
		QvNode*				m_pCamera;
		QvElement::NodeType	m_cameraType;	// perspective or ortho
		bool				m_boolLightOn;
		Ch3DViewerMode		m_viewerMode;
		Ch3DCollisionMode	m_collisionMode;

	public:
		ChQvGlobalSearchState( ChMazeWnd* pView ) :
				ChQvState( pView, findGlobals ),
				m_shading( defaultShading ),
				m_boolLightOn(false),
				m_viewerMode(none),
				m_fAspect(0.),
				m_collisionMode(invalidCollisionMode)
				 				// former bg was .85 gray
		{	
											// The default is now black // changed for 1.1
			m_backGround.set( 0, 0, 0);
		}

		inline ChQvGlobalSearchState* SetShading( ChShadingLevel shading )
			{ m_shading = shading; return this; }
		inline ChQvGlobalSearchState* SetBackground( ChColor backGround )
			{ m_backGround = backGround; return this; }
		inline ChQvGlobalSearchState* SetAspect( float fAspect )
			{ m_fAspect = fAspect; return this; }
		inline ChQvGlobalSearchState* SetCamera( QvNode * pNode, QvElement::NodeType cameraType )
			{ m_pCamera = pNode; m_cameraType = cameraType; return this; }
		inline ChQvGlobalSearchState* SetLightOn()
			{ m_boolLightOn = true; return this; }
		inline ChQvGlobalSearchState*  SetViewerMode(Ch3DViewerMode viewerMode)
			{ m_viewerMode = viewerMode; return this; };
		inline ChQvGlobalSearchState*  SetCollisionMode(Ch3DCollisionMode mode)
			{ m_collisionMode = mode; return this; };

		
		inline float GetAspect()		{ return m_fAspect;}
		inline ChColor	GetBackground()	{ return m_backGround; }
		inline ChShadingLevel GetShading()	{ return m_shading; }
		inline bool GetLightOn()	{ return m_boolLightOn; }
		inline Ch3DViewerMode GetViewerMode()	{ return m_viewerMode; };
		inline Ch3DCollisionMode GetCollisionMode()	{ return m_collisionMode; };

};

class ChQvBounds;

class ChQvBoundsState : public ChQvState
{

	protected:
		//ChQvBounds	*m_pBounds;

	public:
		ChQvBoundsState(ChMazeWnd* pView) : ChQvState(pView, getBounds)
		{
		};

		ChQvBoundsState& operator=( const ChQvState& v );

};

class ChMazeSceneHTTPReq;

class ChQvSpawnState : public ChQvState
{
	public:

	protected:
		bool	m_boolSpawned;
		string 	m_strDefaultURL;

	public:
		ChQvSpawnState(ChMazeWnd* pView, const string &strDefaultURL) :
			ChQvState(pView, spawnRequests), m_boolSpawned(false), m_strDefaultURL(strDefaultURL)
		{
		};

		inline string &GetDefaultURL() { return m_strDefaultURL; };
};

// traverse this to purge unused inlines from all child nodes
#if 1
class ChQvPurgeState : public ChQvState
{
	public:

	protected:

	public:
		ChQvPurgeState(ChMazeWnd* pView) :
			ChQvState(pView, purgeTree)
		{
		};
};
#endif

// Instance tree builder
class ChQvInstance;
class ChQvGroupInstance;

class ChQvBuildState : public ChQvState
{
	public:

	protected:
		ChQvGroupInstance *m_pParent;
		int	iShapeCount;

	public:
		ChQvBuildState(ChMazeWnd* pView) :
			ChQvState(pView, buildInstance), m_pParent(0), iShapeCount(0)
		{
		};

		ChQvGroupInstance *GetCurrentParent() {return m_pParent;};
		ChQvBuildState *SetCurrentParent(ChQvGroupInstance *pParent) {m_pParent = pParent; return this;};
		int AddShape() {iShapeCount++; return iShapeCount;};
		int GetShapeCount() {return iShapeCount;};
		int SetShapeCount(int count) {iShapeCount = count; return iShapeCount;};
};


// Class to read VRML from iostreams; this lets us use strings!
class istream;
class istrstream;

class ChQvInput:public QvInput
{
	public:

	protected:
	  istrstream *m_is;


	public:
		ChQvInput() : QvInput() {};
	    virtual QvBool		get(char &c);
	    virtual QvBool		eof() const;
	    virtual void		putBack(char c);
    	void		setFilePointer(istrstream *newSP) {m_is = newSP;};

};

// Class to read VRML from Memory mapped files;

class ChQvFileMapInput : public  QvInput 
{
	 public:

	    ChQvFileMapInput();
	    ~ChQvFileMapInput();

	    void		setFilePointer(HANDLE hFile );
	    
	    virtual QvBool		get(char &c);
	    virtual QvBool		eof() const;
	    virtual void		putBack(char c);
		void	Abort( )		
					{ 
						m_boolCancel = true;
				 	} 
	  protected:
		HANDLE		m_hFile;		// File handle to map
		HANDLE		m_hFileMap;		// File mapping object
		char*		m_pMappedView;	// Pointer to the mapped file
		long		m_lFileSize;	// Size of the file
		long		m_lCurrIndex;	// current index
		bool		m_boolCancel;
};


#endif	// !defined( _CHMAZE_H )
